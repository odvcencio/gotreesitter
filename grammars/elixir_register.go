// Code generated by ts2go batch. DO NOT EDIT.

package grammars

func init() {
	Register(LangEntry{
		Name:           "elixir",
		Extensions:     []string{".ex", ".exs"},
		Language:       ElixirLanguage,
		HighlightQuery: elixirHighlightQuery,
		TokenSourceFactory: defaultTokenSourceFactory("elixir"),
	})
}

const elixirHighlightQuery = "; Punctuation\n\n[\n \"%\"\n] @punctuation\n\n[\n \",\"\n \";\"\n] @punctuation.delimiter\n\n[\n  \"(\"\n  \")\"\n  \"[\"\n  \"]\"\n  \"{\"\n  \"}\"\n  \"<<\"\n  \">>\"\n] @punctuation.bracket\n\n; Literals\n\n[\n  (boolean)\n  (nil)\n] @constant\n\n[\n  (integer)\n  (float)\n] @number\n\n(char) @constant\n\n; Identifiers\n\n; * regular\n(identifier) @variable\n\n; * unused\n(\n  (identifier) @comment.unused\n  (#match? @comment.unused \"^_\")\n)\n\n; * special\n(\n  (identifier) @constant.builtin\n  (#any-of? @constant.builtin \"__MODULE__\" \"__DIR__\" \"__ENV__\" \"__CALLER__\" \"__STACKTRACE__\")\n)\n\n; Comment\n\n(comment) @comment\n\n; Quoted content\n\n(interpolation \"#{\" @punctuation.special \"}\" @punctuation.special) @embedded\n\n(escape_sequence) @string.escape\n\n[\n  (string)\n  (charlist)\n] @string\n\n[\n  (atom)\n  (quoted_atom)\n  (keyword)\n  (quoted_keyword)\n] @string.special.symbol\n\n; Note that we explicitly target sigil quoted start/end, so they are not overridden by delimiters\n\n(sigil\n  (sigil_name) @__name__\n  quoted_start: _ @string.special\n  quoted_end: _ @string.special) @string.special\n\n(sigil\n  (sigil_name) @__name__\n  quoted_start: _ @string\n  quoted_end: _ @string\n  (#match? @__name__ \"^[sS]$\")) @string\n\n(sigil\n  (sigil_name) @__name__\n  quoted_start: _ @string.regex\n  quoted_end: _ @string.regex\n  (#match? @__name__ \"^[rR]$\")) @string.regex\n\n; Calls\n\n; * local function call\n(call\n  target: (identifier) @function)\n\n; * remote function call\n(call\n  target: (dot\n    right: (identifier) @function))\n\n; * field without parentheses or block\n(call\n  target: (dot\n    right: (identifier) @property)\n  .)\n\n; * remote call without parentheses or block (overrides above)\n(call\n  target: (dot\n    left: [\n      (alias)\n      (atom)\n    ]\n    right: (identifier) @function)\n  .)\n\n; * definition keyword\n(call\n  target: (identifier) @keyword\n  (#any-of? @keyword \"def\" \"defdelegate\" \"defexception\" \"defguard\" \"defguardp\" \"defimpl\" \"defmacro\" \"defmacrop\" \"defmodule\" \"defn\" \"defnp\" \"defoverridable\" \"defp\" \"defprotocol\" \"defstruct\"))\n\n; * kernel or special forms keyword\n(call\n  target: (identifier) @keyword\n  (#any-of? @keyword \"alias\" \"case\" \"cond\" \"for\" \"if\" \"import\" \"quote\" \"raise\" \"receive\" \"require\" \"reraise\" \"super\" \"throw\" \"try\" \"unless\" \"unquote\" \"unquote_splicing\" \"use\" \"with\"))\n\n; * just identifier in function definition\n(call\n  target: (identifier) @keyword\n  (arguments\n    [\n      (identifier) @function\n      (binary_operator\n        left: (identifier) @function\n        operator: \"when\")\n    ])\n  (#any-of? @keyword \"def\" \"defdelegate\" \"defguard\" \"defguardp\" \"defmacro\" \"defmacrop\" \"defn\" \"defnp\" \"defp\"))\n\n; * pipe into identifier (function call)\n(binary_operator\n  operator: \"|>\"\n  right: (identifier) @function)\n\n; * pipe into identifier (definition)\n(call\n  target: (identifier) @keyword\n  (arguments\n    (binary_operator\n      operator: \"|>\"\n      right: (identifier) @variable))\n  (#any-of? @keyword \"def\" \"defdelegate\" \"defguard\" \"defguardp\" \"defmacro\" \"defmacrop\" \"defn\" \"defnp\" \"defp\"))\n\n; * pipe into field without parentheses (function call)\n(binary_operator\n  operator: \"|>\"\n  right: (call\n    target: (dot\n      right: (identifier) @function)))\n\n; Operators\n\n; * capture operand\n(unary_operator\n  operator: \"&\"\n  operand: (integer) @operator)\n\n(operator_identifier) @operator\n\n(unary_operator\n  operator: _ @operator)\n\n(binary_operator\n  operator: _ @operator)\n\n(dot\n  operator: _ @operator)\n\n(stab_clause\n  operator: _ @operator)\n\n; * module attribute\n(unary_operator\n  operator: \"@\" @attribute\n  operand: [\n    (identifier) @attribute\n    (call\n      target: (identifier) @attribute)\n    (boolean) @attribute\n    (nil) @attribute\n  ])\n\n; * doc string\n(unary_operator\n  operator: \"@\" @comment.doc\n  operand: (call\n    target: (identifier) @comment.doc.__attribute__\n    (arguments\n      [\n        (string) @comment.doc\n        (charlist) @comment.doc\n        (sigil\n          quoted_start: _ @comment.doc\n          quoted_end: _ @comment.doc) @comment.doc\n        (boolean) @comment.doc\n      ]))\n  (#any-of? @comment.doc.__attribute__ \"moduledoc\" \"typedoc\" \"doc\"))\n\n; Module\n\n(alias) @module\n\n(call\n  target: (dot\n    left: (atom) @module))\n\n; Reserved keywords\n\n[\"when\" \"and\" \"or\" \"not\" \"in\" \"not in\" \"fn\" \"do\" \"end\" \"catch\" \"rescue\" \"after\" \"else\"] @keyword\n"
