// Code generated by ts2go batch. DO NOT EDIT.

package grammars

func init() {
	Register(LangEntry{
		Name:           "scala",
		Extensions:     []string{".scala"},
		Language:       ScalaLanguage,
		HighlightQuery: scalaHighlightQuery,
		TokenSourceFactory: defaultTokenSourceFactory("scala"),
	})
}

const scalaHighlightQuery = "; CREDITS @stumash (stuart.mashaal@gmail.com)\n\n(field_expression field: (identifier) @property)\n(field_expression value: (identifier) @type\n (#match? @type \"^[A-Z]\"))\n\n(type_identifier) @type\n\n(class_definition\n  name: (identifier) @type)\n\n(enum_definition\n  name: (identifier) @type)\n\n(object_definition\n  name: (identifier) @type)\n\n(trait_definition\n  name: (identifier) @type)\n\n(full_enum_case\n  name: (identifier) @type)\n\n(simple_enum_case\n  name: (identifier) @type)\n\n;; variables\n\n(class_parameter\n  name: (identifier) @parameter)\n\n(self_type (identifier) @parameter)\n\n(interpolation (identifier) @none)\n(interpolation (block) @none)\n\n;; types\n\n(type_definition\n  name: (type_identifier) @type.definition)\n\n;; val/var definitions/declarations\n\n(val_definition\n  pattern: (identifier) @variable)\n\n(var_definition\n  pattern: (identifier) @variable)\n\n(val_declaration\n  name: (identifier) @variable)\n\n(var_declaration\n  name: (identifier) @variable)\n\n; imports/exports\n\n(import_declaration\n  path: (identifier) @namespace)\n((stable_identifier (identifier) @namespace))\n\n((import_declaration\n  path: (identifier) @type) (#match? @type \"^[A-Z]\"))\n((stable_identifier (identifier) @type) (#match? @type \"^[A-Z]\"))\n\n(export_declaration\n  path: (identifier) @namespace)\n((stable_identifier (identifier) @namespace))\n\n((export_declaration\n  path: (identifier) @type) (#match? @type \"^[A-Z]\"))\n((stable_identifier (identifier) @type) (#match? @type \"^[A-Z]\"))\n\n((namespace_selectors (identifier) @type) (#match? @type \"^[A-Z]\"))\n\n; method invocation\n\n(call_expression\n  function: (identifier) @function.call)\n\n(call_expression\n  function: (operator_identifier) @function.call)\n\n(call_expression\n  function: (field_expression\n    field: (identifier) @method.call))\n\n((call_expression\n   function: (identifier) @constructor)\n (#match? @constructor \"^[A-Z]\"))\n\n(generic_function\n  function: (identifier) @function.call)\n\n(interpolated_string_expression\n  interpolator: (identifier) @function.call)\n\n; function definitions\n\n(function_definition\n  name: (identifier) @function)\n\n(parameter\n  name: (identifier) @parameter)\n\n(binding\n  name: (identifier) @parameter)\n\n; method definition\n\n(function_declaration\n      name: (identifier) @method)\n\n(function_definition\n      name: (identifier) @method)\n\n; expressions\n\n(infix_expression operator: (identifier) @operator)\n(infix_expression operator: (operator_identifier) @operator)\n(infix_type operator: (operator_identifier) @operator)\n(infix_type operator: (operator_identifier) @operator)\n\n; literals\n\n(boolean_literal) @boolean\n(integer_literal) @number\n(floating_point_literal) @float\n\n[\n  (string)\n  (character_literal)\n  (interpolated_string_expression)\n] @string\n\n(interpolation \"$\" @punctuation.special)\n\n;; keywords\n\n(opaque_modifier) @type.qualifier\n(infix_modifier) @keyword\n(transparent_modifier) @type.qualifier\n(open_modifier) @type.qualifier\n\n[\n  \"case\"\n  \"class\"\n  \"enum\"\n  \"extends\"\n  \"derives\"\n  \"finally\"\n;; `forSome` existential types not implemented yet\n;; `macro` not implemented yet\n  \"object\"\n  \"override\"\n  \"package\"\n  \"trait\"\n  \"type\"\n  \"val\"\n  \"var\"\n  \"with\"\n  \"given\"\n  \"using\"\n  \"end\"\n  \"implicit\"\n  \"extension\"\n  \"with\"\n] @keyword\n\n[\n  \"abstract\"\n  \"final\"\n  \"lazy\"\n  \"sealed\"\n  \"private\"\n  \"protected\"\n] @type.qualifier\n\n(inline_modifier) @storageclass\n\n(null_literal) @constant.builtin\n\n(wildcard) @parameter\n\n(annotation) @attribute\n\n;; special keywords\n\n\"new\" @keyword.operator\n\n[\n  \"else\"\n  \"if\"\n  \"match\"\n  \"then\"\n] @conditional\n\n[\n \"(\"\n \")\"\n \"[\"\n \"]\"\n \"{\"\n \"}\"\n]  @punctuation.bracket\n\n[\n \".\"\n \",\"\n] @punctuation.delimiter\n\n[\n  \"do\"\n  \"for\"\n  \"while\"\n  \"yield\"\n] @repeat\n\n\"def\" @keyword.function\n\n[\n \"=>\"\n \"<-\"\n \"@\"\n] @operator\n\n[\"import\" \"export\"] @include\n\n[\n  \"try\"\n  \"catch\"\n  \"throw\"\n] @exception\n\n\"return\" @keyword.return\n\n(comment) @spell @comment\n(block_comment) @spell @comment\n\n;; `case` is a conditional keyword in case_block\n\n(case_block\n  (case_clause (\"case\") @conditional))\n(indented_cases\n  (case_clause (\"case\") @conditional))\n\n(operator_identifier) @operator\n\n((identifier) @type (#match? @type \"^[A-Z]\"))\n((identifier) @variable.builtin\n (#match? @variable.builtin \"^this$\"))\n\n(\n  (identifier) @function.builtin\n  (#match? @function.builtin \"^super$\")\n)\n\n;; Scala CLI using directives\n(using_directive_key) @parameter\n(using_directive_value) @string\n"
